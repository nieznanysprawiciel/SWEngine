/**
@page ObjectPipeline Potok przetwarzania obiektów

@section Contents Spis Treœci
- @ref Code
- @ref generalInfo
- @ref pipelineScheme

@subsection Code
@code
void Engine::render_frame()
{
	float time_interval;
	time_controller( time_interval );


#ifdef FIXED_FRAMES_COUNT
	while ( lag >= FIXED_MOVE_UPDATE_INTERVAL )
	{
		ui_engine->proceed_input( time_interval );
		physic_engine->proceed_physic( FIXED_MOVE_UPDATE_INTERVAL );
		controllers_engine->proceed_controllers_pre( FIXED_MOVE_UPDATE_INTERVAL );
		movement_engine->proceed_movement( FIXED_MOVE_UPDATE_INTERVAL );
		controllers_engine->proceed_controllers_post( FIXED_MOVE_UPDATE_INTERVAL );
		collision_engine->proceed_collisions( FIXED_MOVE_UPDATE_INTERVAL );
		fable_engine->proceed_fable( FIXED_MOVE_UPDATE_INTERVAL );

		lag -= FIXED_MOVE_UPDATE_INTERVAL;
	}
#else
	ui_engine->proceed_input( time_interval );
	physic_engine->proceed_physic(time_interval);
	controllers_engine->proceed_controllers_pre(time_interval);
	movement_engine->proceed_movement(time_interval);
	controllers_engine->proceed_controllers_post(time_interval);
	collision_engine->proceed_collisions(time_interval);
	fable_engine->proceed_fable(time_interval);

#endif

#ifdef _INTERPOLATE_POSITIONS
	display_engine->interpolate_positions( lag / FIXED_MOVE_UPDATE_INTERVAL );
#endif

	//Renderujemy scenê oraz interfejs u¿ytkownika
	begin_scene();

	display_engine->display_scene( time_interval, lag / FIXED_MOVE_UPDATE_INTERVAL );
	ui_engine->draw_GUI( time_interval, lag / FIXED_MOVE_UPDATE_INTERVAL );

	end_scene_and_present();
@endcode

@subsection generalInfo Ogólne informacje
Za potok przetwarzania obiektów odpowiada funkcja Engine::render_frame. Funkcja ta jest wywo³ywana w pêtli g³ównej silnika, konkretniej w funkcji Engine::main_loop, w ka¿dym mo¿liwym momencie, kiedy nie s¹ przetwarzane komunikaty z kolejki komunikatów WinApi.

Funkcja wywo³uje w odpowiedniej kolejnoœci poszczególne modu³y silnika. Modu³y odpowiedzialne za ruch obiektów na scenie i ich interakcje wywo³ywane s¹ ze sta³¹ czêstotliwoœci¹ okreœlon¹ przez sta³¹ FIXED_MOVE_UPDATE_INTERVAL. Oznacza to, ¿e w niektórych obiegach pêtli mog¹ nie zostaæ wywo³ane, je¿eli odleg³oœæ w czasie od odstatniego wywo³ania jest za ma³a. Taka architektura ma na celu spowodowanie, ¿eby gra dzia³a³a tak samo zarówno na szybkim sprzêcie jak i na wolnym. Zauwa¿my, ¿e jedno przesuniêcie obiektów po czasie t, nie jest równowa¿ne dwóm przesuniêciom po czasie t/2. Dzieje siê tak ze wzglêdu na niedok³adnoœæ obliczeñ wykonywanych na floatach. O ile w tym przypadku ró¿nice nie musz¹ byæ du¿e, to ró¿nica zachowania sztucznej inteligencji w tych dwóch sytuacjach jest nie do przewidzenia.
Za pomoc¹ tego samego mechanizmu realizowane jest pauzowanie gry. Wtedy czas nie przyrasta, wiêc odpowiednie bloki nie zostaj¹ wywo³ane.

@deprecated
Modu³y silnika odpowiedzialne za renderowanie obiektów, GUI oraz przechwytywanie urz¹dzeñ wejœciowych s¹ wywo³ywane w ka¿dym obiegu pêtli.
Obs³uga eventów wywo³ywana jest wed³ug schematu dwukrotnie. Jest to konieczne, gdy¿ chcemy obs³ugiwaæ eventy tak¿e wtedy, kiedy jesteœmy w trybie pauzy. Nie mo¿emy zabraæ obs³ugi eventów z bloku wykonywanego warunkowo, poniewa¿ po ka¿dym przeliczeniu po³o¿eñ i parametrów obiektów, mog¹ zostaæ wygenerowane nowe zdarzenia, które trzeba obs³u¿yæ. Blok mo¿e zostaæ wtedy ponownie wykonany, z powodu opóŸnienia. W takiej sytuacji obs³uga eventów poza pêtl¹ odby³aby siê za póŸno.
Z tych wzglêdów musimy wywo³aæ obs³ugê zarówno po ka¿dym obiegu bloku warunkowego jak i po wyjœciu z niego. Nie powoduje to ¿adnego spowolnienia. Nadmiarowa procedura natrafia w takim wypadku na pust¹ kolejkê eventów i natychmiast powraca.

Jak widaæ ze schematu obs³uga kontrolerów podzielona jest na dwie czêœci: kontrolery pre i kontrolery post. Dla niektórych grup kotrolerów wymagane jest, aby pozycje pozosta³ych obiektów dynamicznych by³ ju¿ znane, inne maj¹ wp³yw na póŸniejsze przeliczenie pozycji, dlatego musz¹ byæ wywo³ane wczeœniej. Aby przeczytaæ wiêcej o tym temacie odsy³am do @ref PrePostControllers.

Renderowanie klatki podzielone jest na dwa etapy: pierwszym jest renderowanie sceny, drugim renderowanie graficznego interfejsu u¿ytkownika. Aby dowiedzieæ siê wiêcej zalecam przeczytaæ tematy: @ref SceneRender i @ref GUIRender. Ze wzglêdu na to, ¿e funkcje BeginScene i EndScene mog¹ byæ wywo³ane tylko raz podczas renderowania jednej klatki, dzieje siê to na tym poziomie, nie wen¹trz jednej z tych funkcji. Podobnie na tym poziomie realizowane jest czyszczenie bufora kolorów oraz z-bufora.

Funkcja Engine::time_controller wywo³ywana na pocz¹tku robi dwie rzeczy. Po pierwsze liczy czas jaki up³yn¹³ od ostatniego wywo³ania i ustawia zmienn¹ lag. Przy ustawianiu bierze pod uwagê czy jesteœmy w trybie pauzy czy nie, w zwi¹zku z czym na tym poziomie nie musimy siê o nic martwiæ.
Drugim zadaniem jest generowanie eventów zwi¹zanych z czasem i opóŸnieniami.

@subsection pipelineScheme Schemat potoku przetwarzania obiektów
@image html "documentation/pipeline.jpg"
*/