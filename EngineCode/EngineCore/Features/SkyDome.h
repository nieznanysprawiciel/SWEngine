#pragma once

/**@file SkyDome.h
@author nieznanysprawiciel
@copyright Plik jest czêœci¹ silnika graficznego SWEngine.

@brief Plik zawiera deklracjê interfejsu SkyDome, po którym dziedzicz¹ klasy obs³uguj¹ce 
obiekty typu skyboxy, skydome'y i wszystkie inne twory, wyœwietlaj¹ce t³o.*/


#include "GraphicAPI/MeshResources.h"
#include "EngineCore/ModelsManager/ModelsManager.h"
#include "GraphicAPI/IRenderer.h"


/**@brief Klasa jest interfejsem dla wszystkich klas, które maj¹ wyœwietlaæ jakieœ t³o.

Interfejs zawiera jedynie metody do komunikacji z klasa DisplayEngine. Poza tym nie ma koniecznoœci
tworzenia jednolitego interfejsu. Nawet nie jest to do koñca mo¿liwe, bo u¿ytkownik musi podaæ do inicjacji
dane specyficzne dla konkretnego modelu nieba.

Implementuj¹c w³asn¹ klasê, trzeba pamiêtaæ, ¿e po dodaniu do DisplayEngine, obiekt musi byæ w ka¿dej chwili gotowy
do wyœwietlania. Trzeba tak¿e uwa¿aæ na wielowatkowoœæ, aby nie wystêpowa³y niespójnoœci w danych. Klasa DisplayEngine
nie bêdzie u¿ywa³a ¿adnych narzêdzi do synchronizacji, wiêc jedyne istniej¹ce, to te wbudowane w bufory.

W strukturze ModelPart pole mesh jest zainicjowane zaalokowan¹ struktur¹ MeshPartObject i jest równie¿ zwalaniane
w destruktorze klasy SkyDome.

Polecam zapoznaæ siê z opisem funkcji DisplayEngine::display_sky_box w celu lepszego zorientowania siê
co siê dzieje podczas wyœwietlania kopu³y.

@note U¿ywaj¹c funkcji przeznaczonych do wype³niania poszczególnych pól klasy, zwalniamy z siebie obowi¹zek
dodawania odwo³añ. Funkcje pilnuj¹ tak¿e, ¿eby kasowaæ odwo³ania w przypadku, gdy jakieœ pole zosta³o nadpisane.
Wszystkie odwo³ania do obiektów s¹ kasowane w destruktorze, wiêc nie trzeba siê wogóle przejmowaæ ¿adnymi odwo³aniami.
*/
class SkyDome
{
public:
	bool update_vertex_buffer;			///<Ustawiane w momencie zakoñczenia generowania nieba, w celu zaktualizowania bufora
private:
	ModelsManager* models_manager;		///<WskaŸnik na ModelsManager. Bufory s¹ zarz¹dzane przez niego.

protected:
	BufferObject*				vertex_buffer;			///<Bufor wierzcho³ków
	BufferObject*				index_buffer;			///<Bufor indeksów
	BufferObject*				constant_buffer;		///<Bufor sta³ych dla shaderów
	ShaderInputLayout*	layout;					///<Layout wierzcho³ków u¿ywanych przez klasê
	ModelPart					display_data;			///<Shadery, tekstury itp.

public:
	SkyDome( ModelsManager* man )
		: models_manager( man ),
		vertex_buffer( nullptr ),
		index_buffer( nullptr ),
		constant_buffer( nullptr ),
		layout( nullptr )
	{
		display_data.mesh = new MeshPartObject;
		update_vertex_buffer = false;
	}

	virtual ~SkyDome()
	{
		if ( vertex_buffer )
			vertex_buffer->DeleteObjectReference(), vertex_buffer = nullptr;
		if ( index_buffer )
			index_buffer->DeleteObjectReference(), index_buffer = nullptr;
		if ( layout )
			layout->DeleteObjectReference(), layout = nullptr;
		if ( constant_buffer )
			constant_buffer->DeleteObjectReference(), constant_buffer = nullptr;

		if ( display_data.mesh )
			delete display_data.mesh, display_data.mesh = nullptr;
		if ( display_data.pixel_shader )
			display_data.pixel_shader->DeleteObjectReference(), display_data.pixel_shader = nullptr;
		if ( display_data.vertex_shader )
			display_data.vertex_shader->DeleteObjectReference(), display_data.vertex_shader = nullptr;
		if ( display_data.material )
			display_data.material->DeleteObjectReference(), display_data.material = nullptr;
		for ( int i = 0; i < ENGINE_MAX_TEXTURES; ++i )
			if ( display_data.texture[i] )
				display_data.texture[i]->DeleteObjectReference(), display_data.texture[i] = nullptr;
	}

	inline BufferObject*			get_vertex_buffer()		{ return vertex_buffer; }				///<Zwraca bufor wierzcho³ków
	inline BufferObject*			get_index_buffer()		{ return index_buffer; }				///<Zwraca bufor indeksów
	inline BufferObject*			get_constant_buffer()	{ return constant_buffer; }				///<Zwraca bufor sta³ych dla shaderów
	inline ShaderInputLayout*	get_vertex_layout()		{ return layout; }						///<Zwraca layout wierzcho³ka
	inline ModelPart*				get_model_part()		{ return &display_data; }				///<Zwraca dane potrzebne do wyœwietlania

	/**@brief Funkcja jest wywo³ywana w momencie kiedy zmienna update_vertex_buffer zawiera wartoœæ true.
	
	Zadaniem funkcji jest wype³nienie bufora indeksów lub wierzcho³ków nowymi danymi, które zosta³y przygotowane
	gdzieœ w buforach tylnich. Dane powinny byæ generowane inn¹ funkcj¹, której nie ma w tym interfejsie, przez
	jak¹œ funkcjê spoza klasy DisplayEngine i najlepiej w innym w¹tku. Zadaniem tej funkcji jest jedynie
	wywo³anie funkcji UpdateSubresource na tych buforach, które wymagaj¹ aktualizacji.
	
	@attention Nie nale¿y generowaæ danych w tej funkcji chyba, ¿e jest ich naprawdê niewiele. Ta funkcja
	bêdzie wywo³ywana w pêtli g³ównej i mo¿e zaburzyæ renderowanie.
	
	Pole update_vertex_buffer powinno zostaæ ustawione na false po wykonaniu tej funkcji.*/
	virtual void update_buffers( IRenderer* renderer ) = 0;
protected:
	// Funkcje do ustawiania

	/**@brief Funkcja ustawia w zmiennej display_data teksturê.
	Tekstura jest pobierana z ModelsManagera, je¿eli nie istnieje jest dodawana.
	
	@param[in] name Nazwa pliku z tekstur¹.
	@param[in] type Pozycja w tablicy, do której zostaniej przypisana tekstura.*/
	inline void set_texture( const std::wstring& name, TextureUse type )
	{
		if ( type > ENGINE_MAX_TEXTURES )
			return;

		auto tex = models_manager->LoadTexture( name );
		if ( !tex )
			return;	// Zabezpieczenie przed nullptrem

		if ( display_data.texture[type] )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			display_data.texture[type]->DeleteObjectReference();

		tex->AddObjectReference();
		display_data.texture[type] = tex;
	}
	/**@brief Funkcja ustawia w zmiennej display_data vertex shader.
	Shader jest pobierany z ModelsManagera, je¿eli nie istnieje jest dodawany.

	@param[in] file_name Nazwa pliku z shaderem.
	@param[in] shader_entry Nazwa funkcji shadera.
	@param[in] layout_desc Deskryptor formatu wierzcho³ka.
	@param[in] array_size Liczba elementów tablicy layout_desc.*/
	inline void set_vertex_shader( const std::wstring& file_name,
								   const std::string& shader_entry,
								   InputLayoutDescriptor* layout_desc )
	{
		if ( layout )	// Zwalniamy layout, je¿eli jakiœ by³
			layout->DeleteObjectReference();

		auto shader = models_manager->LoadVertexShader( file_name, shader_entry, &layout, layout_desc );
		if ( !shader )
			return;	// Zabezpieczenie przed nullptrem
		if ( !layout )
			return;	// Je¿eli layout siê nie chcia³ stworzyæ to lepiej nie dodawaæ te¿ vertex shadera

		if ( display_data.vertex_shader )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			display_data.vertex_shader->DeleteObjectReference( );

		shader->AddObjectReference( );
		display_data.vertex_shader = shader;
	}
	/**@brief Funkcja ustawia w zmiennej display_data pixel shader.
	Shader jest pobierany z ModelsManagera, je¿eli nie istnieje jest dodawany.

	@param[in] file_name Nazwa pliku z shaderem.
	@param[in] shader_entry Nazwa funkcji shadera.*/
	inline void set_pixel_shader( const std::wstring& file_name, const std::string& shader_entry )
	{
		auto shader = models_manager->LoadPixelShader( file_name, shader_entry );
		if ( !shader )
			return;	// Zabezpieczenie przed nullptrem

		if ( display_data.pixel_shader )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			display_data.pixel_shader->DeleteObjectReference( );

		shader->AddObjectReference( );
		display_data.pixel_shader = shader;
	}
	/**@brief Funkcja ustawia w zmiennej display_data materia³.
	Materia³ jest pobierany z ModelsManagera, je¿eli nie istnieje jest dodawany.

	@param[in] material Materia³, który ma zostaæ dodany
	@param[in] material_name Nazwa materia³u. Do materia³u bêdzie mo¿na siê odwo³aæ podaj¹c ci¹g znaków*/
	inline void set_material( MaterialObject* mat, const std::wstring& name)
	{
		auto material = models_manager->AddMaterial( mat, name );
		if ( !material )
			return;	// Zabezpieczenie przed nullptrem

		if ( display_data.material )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			display_data.material->DeleteObjectReference( );

		material->AddObjectReference( );
		display_data.material = material;
	}
	/**@brief Funkcja tworzy, a potem ustawia w zmiennej vertex_buffer bufor wierzcho³ków.
	Bufor jest pobierany z ModelsManagera, je¿eli nie istnieje jest dodawany.

	@param[in] name Nazwa bufora, po której mo¿na siê bêdzie odwo³aæ.
	@param[in] buffer WskaŸnik na bufor z danym, które maj¹ byæ przeniesione do bufora DirectXowego.
	@param[in] element_size Rozmiar pojedynczego elementu w buforze.
	@param[in] vert_count Liczba wierzcho³ków/indeksów w buforze.*/
	inline void set_vertex_buffer( const std::wstring& name, const void* buffer, unsigned int element_size, unsigned int vert_count )
	{
		VertexBufferInitData initData;
		initData.Data = (const uint8*)buffer;
		initData.ElementSize = element_size;
		initData.NumElements = vert_count;

		auto buff = models_manager->CreateVertexBuffer( name, initData );
		if ( !buff )
			return;	// Zabezpieczenie przed nullptrem

		if ( vertex_buffer )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			vertex_buffer->DeleteObjectReference( );

		buff->AddObjectReference( );
		vertex_buffer = buff.Ptr();
	}
	/**@brief Funkcja tworzy, a potem ustawia w zmiennej index_buffer bufor indeksów.
	Bufor jest pobierany z ModelsManagera, je¿eli nie istnieje jest dodawany.

	@param[in] name Nazwa bufora, po której mo¿na siê bêdzie odwo³aæ.
	@param[in] buffer WskaŸnik na bufor z danym, które maj¹ byæ przeniesione do bufora DirectXowego.
	@param[in] element_size Rozmiar pojedynczego elementu w buforze.
	@param[in] vert_count Liczba wierzcho³ków/indeksów w buforze.*/
	inline void set_index_buffer( const std::wstring& name, const void* buffer, unsigned int element_size, unsigned int vert_count )
	{
		IndexBufferInitData initData;
		initData.Data = (const uint8*)buffer;
		initData.ElementSize = element_size;
		initData.NumElements = vert_count;

		auto buff = models_manager->CreateIndexBuffer( name, initData );
		if ( !buff )
			return;	// Zabezpieczenie przed nullptrem

		if ( index_buffer )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			index_buffer->DeleteObjectReference( );

		buff->AddObjectReference( );
		index_buffer = buff.Ptr();
	}

	/**@brief Funkcja tworzy, a potem ustawia w zmiennej constant_buffer bufor sta³ych.
	Bufor jest pobierany z ModelsManagera, je¿eli nie istnieje jest dodawany.

	@param[in] name Nazwa bufora, po której mo¿na siê bêdzie odwo³aæ.
	@param[in] buffer WskaŸnik na bufor z danym, które maj¹ byæ przeniesione do bufora DirectXowego.
	@param[in] element_size Rozmiar pojedynczego elementu w buforze..*/
	inline void set_constants_buffer( const std::wstring& name, const void* buffer, unsigned int element_size )
	{
		ConstantBufferInitData initData;
		initData.Data = (const uint8*)buffer;
		initData.ElementSize = element_size;
		initData.NumElements = 1;

		auto buff = models_manager->CreateConstantsBuffer( name, initData );
		if ( !buff )
			return;	// Zabezpieczenie przed nullptrem

		if ( index_buffer )	// Je¿eli coœ wczeœniej by³o to kasujemy odwo³anie
			index_buffer->DeleteObjectReference( );

		buff->AddObjectReference( );
		index_buffer = buff.Ptr();
	}
};
