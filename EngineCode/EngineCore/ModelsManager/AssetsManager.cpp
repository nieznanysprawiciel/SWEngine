#include "EngineCore/stdafx.h"
#include "AssetsManager.h"

#include "Loaders/ILoader.h"
#include "Loaders/FBX_files_loader/FBX_loader.h"
#include "Loaders/Texture/TextureLoader.h"
#include "Loaders/Material/SWMat/SWMaterialLoader.h"

#include "Common/ObjectDeleter.h"
#include "Common/MacrosSwitches.h"
#include "GraphicAPI/ResourcesFactory.h"

#include "Common/Converters.h"

#include "Common/MemoryLeaks.h"

using namespace DirectX;

//-------------------------------------------------------------------------------//
//							wersja DirectX11
//-------------------------------------------------------------------------------//

AssetsManager::AssetsManager( Engine* engine )
: m_engine( engine )
{
	Model3DFromFile::models_manager = this;

	//Loader plików FBX jest domyœlnym narzêdziem do wczytywania
	FBX_loader* fbx_loader = new FBX_loader( this );
	m_loader.push_back( fbx_loader );
}



AssetsManager::~AssetsManager( )
{
	// Kasujemy obiekty do wczytywania danych
	for ( unsigned int i = 0; i <  m_loader.size(); ++i )
		delete m_loader[i];
}




/**@brief Dopasowuje najlepszy z domyœlnych shaderów, który pasuje do podanej tablicy
tekstur. Tablica ma tyle elementów ile zmienna @ref ENGINE_MAX_TEXTURES.

Ka¿da pozycja w tablicy ma przypisane domyœlne znaczenie zgodnie z enumeracj¹ 
@ref TextureUse. Najlepszy shader jest wybierany na podstawie obecnoœci
lub nieobecnoœci tekstury w tablicy.

@todo Oddelegowaæ jakiœ inny obiekt do obœ³ugi wartoœci domyœlnych albo przemyœleæ lepiej jak to powinno w³aœciwie wygl¹daæ.

@param[in] textures Tablica tekstur z obiektu ModelPart.
@return Zwraca obiekt vertex shadera.*/
VertexShader*	AssetsManager::FindBestVertexShader	( TextureObject** textures )
{
	// Na razie nie mamy innych domyœlnych shaderów
	return m_vertexShader.get( DefaultAssets::DEFAULT_VERTEX_SHADER_STRING );
}


/**@brief Dopasowuje najlepszy z domyœlnych shaderów, który pasuje do podanej tablicy
tekstur. Tablica ma tyle elementów ile zmienna @ref ENGINE_MAX_TEXTURES.

Ka¿da pozycja w tablicy ma przypisane domyœlne znaczenie zgodnie z enumeracj¹
@ref TextureUse. Najlepszy shader jest wybierany na podstawie obecnoœci
lub nieobecnoœci tekstury w tablicy.

@todo Oddelegowaæ jakiœ inny obiekt do obœ³ugi wartoœci domyœlnych albo przemyœleæ lepiej jak to powinno w³aœciwie wygl¹daæ.

@param[in] textures Tablica tekstur z obiektu ModelPart.
@return Zwraca obiekt pixel shadera.*/
PixelShader*	AssetsManager::FindBestPixelShader	( TextureObject** textures )
{
	PixelShader* return_shader = nullptr;

	// Na razie nie ma innych tekstur ni¿ diffuse, wiêc algorytm nie jest skomplikowany
	if( textures[ TextureUse::TEX_DIFFUSE ] )
		return_shader = m_pixelShader.get( DefaultAssets::DEFAULT_TEX_DIFFUSE_PIXEL_SHADER_PATH );


	if( !return_shader )	// Je¿eli nadal jest nullptrem to dajemy mu domyœlny shader
		return_shader = m_pixelShader.get( DefaultAssets::DEFAULT_PIXEL_SHADER_STRING );

	return return_shader;
}

/**@brief */
GeometryShader*		AssetsManager::FindBestGeometryhader	( TextureObject** textures )
{
	return nullptr;
}

/**@brief */
EvaluationShader*	AssetsManager::FindBestEvaluationShader	( TextureObject** textures )
{
	return nullptr;
}

/**@brief */
ControlShader*		AssetsManager::FindBestControlShader	( TextureObject** textures )
{
	return nullptr;
}


/**@brief Fills struct with best shaders matching to textures data.*/
void			AssetsManager::FillBestShaders		( MaterialInitData& initData )
{
	TextureObject* textures[ MAX_MATERIAL_TEXTURES ];
	for( int i = 0; i < MAX_MATERIAL_TEXTURES; i++ )
		textures[ i ] = initData.Textures[ i ].Ptr();

	initData.VertexShader = FindBestVertexShader( textures );
	initData.PixelShader = FindBestPixelShader( textures );
	initData.GeometryShader = FindBestGeometryhader( textures );
	initData.TesselationEvaluationShader = FindBestEvaluationShader( textures );
	initData.TesselationControlShader = FindBestControlShader( textures );
}


/** @brief Znajduje Loader pasuj¹cy do pliku podanego w parametrze.
@param[in] path Œcie¿ka do pliku, dla której szukamy loadera.
@return WskaŸnik na odpowiedni loader lub nullptr, je¿eli nie znaleziono pasuj¹cego.*/
ILoader*		AssetsManager::FindLoader			( const std::wstring& path )
{
	for ( unsigned int i = 0; i <  m_loader.size( ); ++i )
	if ( m_loader[i]->can_load( path ) )
		return m_loader[i];
	return nullptr;
}


//-------------------------------------------------------------------------------//
//							Loading functions
//-------------------------------------------------------------------------------//



/**@brief Wczytuje model z podanego pliku.
@param[in] file Plik do wczytania
@return Jedna z wartoœci @ref ModelsManagerResult. Funkcja mo¿e zwróciæ @ref ModelsManagerResult::MODELS_MANAGER_OK,
@ref ModelsManagerResult::MODELS_MANAGER_LOADER_NOT_FOUND lub @ref ModelsManagerResult::MODELS_MANAGER_CANNOT_LOAD.*/
ModelsManagerResult AssetsManager::LoadModelFromFile( const std::wstring& file )
{
	// Sprawdzamy czy plik nie zosta³ ju¿ wczytany
	Model3DFromFile* new_model = m_fileModel.get( file );
	if ( new_model != nullptr )
		return ModelsManagerResult::MODELS_MANAGER_OK;	// Udajemy, ¿e wszystko posz³o dobrze

	// Sprawdzamy, który loader potrafi otworzyæ plik
	ILoader* loader = FindLoader( file );
	if ( loader == nullptr )
		return ModelsManagerResult::MODELS_MANAGER_LOADER_NOT_FOUND;		// ¯aden nie potrafi

	// Tworzymy obiekt Model3DFromFile, do którego loader wpisze zawartoœæ pliku
	new_model = new Model3DFromFile( file );

	// Wszystkie operacje wpisywania musz¹ byæ zamkniête tymi wywo³aniami
	new_model->BeginEdit();
	LoaderResult result = loader->load_mesh( new_model, file );
	new_model->EndEdit();

	if ( result != LoaderResult::MESH_LOADING_OK )
	{	// load_mesh powinno zwróciæ 0
		// Destruktor jest prywatny, wiêc nie mo¿emy kasowaæ obiektu bezpoœrednio.
		ObjectDeleter< Model3DFromFile>::delete_object( new_model, ObjectDeleterKey< Model3DFromFile>() );
		return ModelsManagerResult::MODELS_MANAGER_CANNOT_LOAD;
	}

	// Dodajemy model do tablic
	m_fileModel.UnsafeAdd( file, new_model );

	return ModelsManagerResult::MODELS_MANAGER_OK;
}

/**@brief Loads mesh from file.
@return Returns nullptr when loader could not be found or mesh loading failed.*/
ResourcePtr< MeshAsset >		AssetsManager::LoadMesh		( const filesystem::Path& file )
{
	std::wstring filePath = file.WString();

	// Check exisitng meshes.
	MeshAsset* newMesh = m_meshes.get( filePath );
	if ( newMesh != nullptr )
		return newMesh;

	ILoader* loader = FindLoader( filePath );
	if ( loader == nullptr )
		return nullptr;

	Nullable< MeshInitData > meshData = loader->LoadMesh( file );
	if( !meshData.IsValid )
	{
		///@todo Use logging mechanism to log error.
		return nullptr;
	}

	return CreateMesh( filePath, std::move( meshData.Value ) );
}

/**@brief Loads material from file.*/
ResourcePtr< MaterialAsset >	AssetsManager::LoadMaterial	( const filesystem::Path& file )
{
	std::wstring filePath = Convert::FromString< std::wstring >( file.String(), L"" );

	// Check exisitng materials.
	MaterialAsset* newMaterial = m_material.get( filePath );
	if ( newMaterial != nullptr )
		return newMaterial;

	SWMaterialLoader loader( this );

	if( !loader.CanLoad( file ) )
	{
		/// @todo Log message.
		return nullptr;
	}

	Nullable< MaterialInitData > materialData = loader.LoadMaterial( file );
	if( !materialData.IsValid )
	{
		///@todo Use logging mechanism to log error.
		return nullptr;
	}

	return CreateMaterial( filePath, std::move( materialData.Value ) );
}

//====================================================================================//
//			Assets creation	
//====================================================================================//

/**@brief Creates mesh from provided data.*/
ResourcePtr< MeshAsset >		AssetsManager::CreateMesh	( const std::wstring& name, MeshInitData&& initData )
{
	VertexBufferInitData vertexInit;
	vertexInit.Data = initData.VertexBuffer.GetMemory< uint8 >();
	vertexInit.Usage = ResourceUsage::RESOURCE_USAGE_STATIC;
	vertexInit.ElementSize = initData.VertexSize;
	vertexInit.NumElements = initData.NumVerticies;
	vertexInit.VertexLayout = initData.VertexLayout;
	vertexInit.Topology = initData.Topology;

	auto vertexBuffer = CreateVertexBuffer( name, vertexInit );
	if( !vertexBuffer )
		return nullptr;

	ResourcePtr< BufferObject > indexBuffer;
	if( !initData.IndexBuffer.IsNull() )
	{
		IndexBufferInitData indexInit;
		indexInit.Data = initData.IndexBuffer.GetMemory< uint8 >();
		
		if( initData.ExtendedIndex )
		{
			indexInit.DataType = TypeID::get< Index32 >();
			indexInit.ElementSize = sizeof( Index32 );
		}
		else
		{
			indexInit.ElementSize = sizeof( Index16 );
			indexInit.DataType = TypeID::get< Index16 >();
		}

		indexInit.Topology = initData.Topology;
		indexInit.NumElements = initData.NumIndicies;
		indexInit.Usage = ResourceUsage::RESOURCE_USAGE_STATIC;

		indexBuffer = CreateIndexBuffer( name, indexInit );
		if( !indexBuffer )
			return nullptr;
	}

	// Validate segments data
	for( auto& segment : initData.MeshSegments )
	{
		uint16 flags = 0;
		if( initData.ExtendedIndex )
			flags = flags | MeshPartFlags::Use4BytesIndex;

		if( segment.Material->GetDescriptor().AdditionalBuffers.size() != 0 )
			flags = flags | MeshPartFlags::UseAdditionalBuffer;

		segment.Flags = flags;
	}

	MeshCreateData meshData;
	meshData.MeshSegments = std::move( initData.MeshSegments );
	meshData.VertexLayout = std::move( initData.VertexLayout );
	meshData.VertexBuffer = std::move( vertexBuffer );
	meshData.IndexBuffer = std::move( indexBuffer );

	return CreateMesh( name, std::move( meshData ) );
}

/**@brief Creates MeshAsset.

@return Returns nullptr if asset under this name existed in AssetManager before.
@note This is difference between CreateMesh and LoadMesh. LoadMesh returns existing
material not nullptr in this case.*/
ResourcePtr< MeshAsset >		AssetsManager::CreateMesh		( const std::wstring& name, MeshCreateData&& initData )
{
	// Check exisitng materials.
	MeshAsset* newMesh = m_meshes.get( name );
	if ( newMesh != nullptr )
		return nullptr;

	newMesh = new MeshAsset( name, std::move( initData ) );
	m_meshes.UnsafeAdd( name, newMesh );

	return newMesh;
}

/**@brief Creates MaterialAsset.

@return Returns nullptr if asset under this name existed in AssetManager before.
@note This is difference between CreateMaterial and LoadMaterial. LoadMaterial returns existing
material not nullptr in this case.*/
ResourcePtr< MaterialAsset >	AssetsManager::CreateMaterial	( const std::wstring& name, MaterialInitData&& initData )
{
	if( !initData.ShadingData )
		return nullptr;

	ConstantBufferInitData bufferData;
	bufferData.DataType = initData.ShadingData->GetShadingModelType();
	bufferData.ElementSize = (uint32)initData.ShadingData->GetShadingModelSize();
	bufferData.Data = initData.ShadingData->GetShadingModelData();

	// Constant buffers must be 16 bytes aligned.
	if( bufferData.ElementSize % 16 != 0 )
	{
		///@todo Logging
		return nullptr;
	}

	auto materialBuffer = CreateConstantsBuffer( name, bufferData );
	if( !materialBuffer )
		return nullptr;

	MaterialCreateData data;
	data.Data = std::move( initData );
	data.MaterialBuffer = materialBuffer;

	return CreateMaterial( name, std::move( data ) );
}

/**@brief Creates MaterialAsset.

@return Returns nullptr if asset under this name existed in AssetManager before.
@note This is difference between CreateMaterial and LoadMaterial. LoadMaterial returns existing
material not nullptr in this case.*/
ResourcePtr< MaterialAsset >	AssetsManager::CreateMaterial				( const std::wstring& name, MaterialCreateData&& initData )
{
	// Check exisitng materials.
	MaterialAsset* newMaterial = m_material.get( name );
	if ( newMaterial != nullptr )
		return nullptr;

	newMaterial = new MaterialAsset( name, std::move( initData ) );
	m_material.UnsafeAdd( name, newMaterial );

	return newMaterial;
}

/**@brief Dodaje materia³ do AssetManagera, je¿eli jeszcze nie istnia³.
@note Funkcja nie dodaje odwo³ania do obiektu, bo nie zak³ada, ¿e ktoœ go od razu u¿yje.
W ka¿dym miejscu, gdzie zostanie przypisany zwrócony obiekt, nale¿y pamiêtaæ o dodaniu odwo³ania oraz
skasowaniu go, gdy obiekt przestanie byæ u¿ywany.

@note Je¿eli materia³ ju¿ istnia³ (jego nazwa), to ten podany w parametrze nie zostanie dodany.
Oznacza to, ¿e za jego zwolnienie odpowiada ten, kto go stworzy³. Trzeba zawsze sprawdziæ czy
zwrócona wartoœæ jest tym samym co podaliœmy.

@todo Nie mo¿e tak zostaæ, ¿e ktoœ dodaje materia³ i musi sprawdziæ czy nie dosta³ innego. Nie mo¿na
te¿ zmuszaæ kogoœ do zwalniania pamiêci po materiale.

@param[in] material Materia³, który ma zostaæ dodany
@param[in] materialName Nazwa materia³u. Do materia³u bêdzie mo¿na siê odwo³aæ podaj¹c ci¹g znaków
[nazwa_pliku]::[nazwa_materia³u]. Oznacza to, ¿e mog¹ istnieæ dwa takie same materia³y, poniewa¿ nie jest sprawdzana
zawartoœæ, a jedynie nazwy.
@return Zwraca wskaŸnik na dodany materia³.*/
MaterialObject* AssetsManager::AddMaterialObject( MaterialObject* addMaterial, const std::wstring& materialName )
{
	MaterialObject* newMaterial = m_materialObject.get( materialName );
	if ( !newMaterial )
		m_materialObject.UnsafeAdd( materialName, addMaterial );	// Dodaliœmy materia³

	return newMaterial;
}


//====================================================================================//
//			Listowanie assetów
//====================================================================================//


/**@brief Listowanie materia³ów.*/
std::vector< ResourcePtr< MaterialAsset > >		AssetsManager::ListMaterials()
{
	return m_material.List();
}

/**@brief Listowanie meshy.*/
std::vector< ResourcePtr< MeshAsset > >			AssetsManager::ListMeshes()
{
	return m_meshes.List();
}

/**@brief Implementation of texture loading.

This is hack function. Resource manager have no texture loading function beacause
it needs separate library for this. Derived classes will implement it, but in future
this must change. ResourceManager must be fully operational class. Otherwise GUI 
won't load textures.*/
MemoryChunk										AssetsManager::LoadTextureImpl	( const filesystem::Path& filePath, TextureInfo& texInfo )
{
	return TextureLoader::LoadTexture( texInfo.FilePath, texInfo );
}

