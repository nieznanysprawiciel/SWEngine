<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>Schopenhauers Weltschmerz Engine: LightmapWorkerCPU Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Schopenhauers Weltschmerz Engine
   &#160;<span id="projectnumber">Wersja 1.010</span>
   </div>
   <div id="projectbrief">SWEngine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="class_lightmap_worker_c_p_u-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LightmapWorkerCPU Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Inheritance diagram for LightmapWorkerCPU:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_lightmap_worker_c_p_u.png" usemap="#LightmapWorkerCPU_map" alt=""/>
  <map id="LightmapWorkerCPU_map" name="LightmapWorkerCPU_map">
<area href="class_lightmap_worker.html" alt="LightmapWorker" shape="rect" coords="0,0,128,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b3f891f7882b279ccd93b8161166457"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8b3f891f7882b279ccd93b8161166457"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LightmapWorkerCPU</b> (<a class="el" href="struct_scene_data.html">SceneData</a> *sceneData)</td></tr>
<tr class="separator:a8b3f891f7882b279ccd93b8161166457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e808396ddda82c952c83b59e530f59f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0e808396ddda82c952c83b59e530f59f"></a>
virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#a0e808396ddda82c952c83b59e530f59f">Generate</a> () override</td></tr>
<tr class="memdesc:a0e808396ddda82c952c83b59e530f59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Główna funkcja generująca lightmapy. Zaimplementuj w klasie pochodnej. <br /></td></tr>
<tr class="separator:a0e808396ddda82c952c83b59e530f59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_lightmap_worker"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_lightmap_worker')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_lightmap_worker.html">LightmapWorker</a></td></tr>
<tr class="memitem:ac6e1348bf84c31e67fbc32ab4cd65482 inherit pub_methods_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac6e1348bf84c31e67fbc32ab4cd65482"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>LightmapWorker</b> (<a class="el" href="struct_scene_data.html">SceneData</a> *sceneData)</td></tr>
<tr class="separator:ac6e1348bf84c31e67fbc32ab4cd65482 inherit pub_methods_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c5224425b56a622afcbbe60d06b45c inherit pub_methods_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a58c5224425b56a622afcbbe60d06b45c"></a>
<a class="el" href="struct_scene_data.html">SceneData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>GetSceneData</b> ()</td></tr>
<tr class="separator:a58c5224425b56a622afcbbe60d06b45c inherit pub_methods_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab89dae6f9900a2453946d2de78b0ffc8 inherit pub_methods_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab89dae6f9900a2453946d2de78b0ffc8"></a>
LightmapState&#160;</td><td class="memItemRight" valign="bottom"><b>GetState</b> ()</td></tr>
<tr class="separator:ab89dae6f9900a2453946d2de78b0ffc8 inherit pub_methods_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4bce346ade8035635c570aee19df2c inherit pub_methods_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2e4bce346ade8035635c570aee19df2c"></a>
std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><b>MoveResult</b> ()</td></tr>
<tr class="separator:a2e4bce346ade8035635c570aee19df2c inherit pub_methods_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aeabf69670c69071c5e5ee76f8cab56 inherit pub_methods_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0aeabf69670c69071c5e5ee76f8cab56"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>SetDepthResolution</b> (unsigned int resolution)</td></tr>
<tr class="separator:a0aeabf69670c69071c5e5ee76f8cab56 inherit pub_methods_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad96e67777cbcb27cd199abecff86c305"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad96e67777cbcb27cd199abecff86c305"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#ad96e67777cbcb27cd199abecff86c305">Prepare</a> (std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;emissionLight, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;reachedLight, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;verticies)</td></tr>
<tr class="memdesc:ad96e67777cbcb27cd199abecff86c305"><td class="mdescLeft">&#160;</td><td class="mdescRight">Przygotowuje odpowiednie struktury do generacji. <br /></td></tr>
<tr class="separator:ad96e67777cbcb27cd199abecff86c305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10302e6e70bd5439e7b03cfab2615f99"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a10302e6e70bd5439e7b03cfab2615f99"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#a10302e6e70bd5439e7b03cfab2615f99">Radiosity</a> (std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;emissionLight, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;reachedLight, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;verticies)</td></tr>
<tr class="memdesc:a10302e6e70bd5439e7b03cfab2615f99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wykonuje algorytm radiosity. <br /></td></tr>
<tr class="separator:a10302e6e70bd5439e7b03cfab2615f99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0e4f8587be43471b164c4c91f2439e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#ae0e4f8587be43471b164c4c91f2439e1">BuildResult</a> (std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;reachedLight)</td></tr>
<tr class="memdesc:ae0e4f8587be43471b164c4c91f2439e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tworzy tablicę color - uv, która zostanie potem użyta do wyrenderowania lightmapy.  <a href="#ae0e4f8587be43471b164c4c91f2439e1">More...</a><br /></td></tr>
<tr class="separator:ae0e4f8587be43471b164c4c91f2439e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae10e3fb1bc239c4fe45597428a51281"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae10e3fb1bc239c4fe45597428a51281"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#aae10e3fb1bc239c4fe45597428a51281">DepthPass</a> (std::tuple&lt; unsigned int, unsigned int, float &gt; &amp;emissionMax, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;verticies, <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;depthBuffer, <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;indexBuffer)</td></tr>
<tr class="memdesc:aae10e3fb1bc239c4fe45597428a51281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wykonuje przebieg z z-buforem. <br /></td></tr>
<tr class="separator:aae10e3fb1bc239c4fe45597428a51281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0460a28b4a2271ff182991aa67e2f1d9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0460a28b4a2271ff182991aa67e2f1d9"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>TransferPass</b> (std::tuple&lt; unsigned int, unsigned int, float &gt; &amp;emissionMax, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;verticies, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;emissionLight, std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;reachedLight, <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;indexBuffer)</td></tr>
<tr class="separator:a0460a28b4a2271ff182991aa67e2f1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af995ff4c404c180ef800a2425eb19bcb"><td class="memItemLeft" align="right" valign="top">DirectX::XMFLOAT3&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#af995ff4c404c180ef800a2425eb19bcb">HemisphereCast</a> (<a class="el" href="struct_triangle4.html">Triangle4</a> &amp;emiter, <a class="el" href="struct_triangle4.html">Triangle4</a> &amp;receiver, DirectX::XMMATRIX &amp;emiterViewMatrix)</td></tr>
<tr class="memdesc:af995ff4c404c180ef800a2425eb19bcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wylicza współrzędne trójkąta zrzutowanego na płaszczyznę koła. Współrzędne są dwuwymiarowe, co pozwala łatwo przejść z nich na indeksy do bufora głębokości.  <a href="#af995ff4c404c180ef800a2425eb19bcb">More...</a><br /></td></tr>
<tr class="separator:af995ff4c404c180ef800a2425eb19bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b255d2928d397250180d951371f66a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_triangle4.html">Triangle4</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#a46b255d2928d397250180d951371f66a">EmiterCoordinatesSystem</a> (<a class="el" href="struct_triangle4.html">Triangle4</a> &amp;emiter)</td></tr>
<tr class="memdesc:a46b255d2928d397250180d951371f66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wyliczamy wektory równoległe do płaszczyzny i wzajemnie ortogonalne.  <a href="#a46b255d2928d397250180d951371f66a">More...</a><br /></td></tr>
<tr class="separator:a46b255d2928d397250180d951371f66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486b509075a01a07b97dbbc62749ba6e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a486b509075a01a07b97dbbc62749ba6e"></a>
DirectX::XMMATRIX&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#a486b509075a01a07b97dbbc62749ba6e">EmiterViewMatrix</a> (<a class="el" href="struct_triangle4.html">Triangle4</a> &amp;emiter)</td></tr>
<tr class="memdesc:a486b509075a01a07b97dbbc62749ba6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tworzy macierz przekształcającą wierzchołki do układu odniesienia emitera. <br /></td></tr>
<tr class="separator:a486b509075a01a07b97dbbc62749ba6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ba92104ba2853a8f03d3575f041fc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#af0ba92104ba2853a8f03d3575f041fc2">RasterizeTriangle</a> (const <a class="el" href="struct_triangle4.html">Triangle4</a> &amp;triangle, DirectX::XMFLOAT3 *depths, unsigned int chunkIdx, unsigned int triangleIdx, <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;depthBuffer, <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;indexBuffer)</td></tr>
<tr class="memdesc:af0ba92104ba2853a8f03d3575f041fc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rasteryzuje podany trójkąt. Sprawdza czy jest bliżej emitera od ostatnio wpisanego trójkąta na podstawie bufora głębokości i jeżeli tak, to zapisuje nowy trójkąt.  <a href="#af0ba92104ba2853a8f03d3575f041fc2">More...</a><br /></td></tr>
<tr class="separator:af0ba92104ba2853a8f03d3575f041fc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ed6504329d00e9d0391a2158cd25b0"><td class="memItemLeft" align="right" valign="top">DirectX::XMVECTOR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#ac4ed6504329d00e9d0391a2158cd25b0">ProjectPointToPlane</a> (DirectX::XMVECTOR point, const <a class="el" href="struct_triangle4.html">Triangle4</a> &amp;coordsSystem)</td></tr>
<tr class="memdesc:ac4ed6504329d00e9d0391a2158cd25b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wylicza rzut punktu na płaszczyznę.  <a href="#ac4ed6504329d00e9d0391a2158cd25b0">More...</a><br /></td></tr>
<tr class="separator:ac4ed6504329d00e9d0391a2158cd25b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744f19b2f2880642d0d3688196b81c94"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a744f19b2f2880642d0d3688196b81c94"></a>
DirectX::XMVECTOR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#a744f19b2f2880642d0d3688196b81c94">AverageNormal</a> (const <a class="el" href="struct_vertex_format.html">VertexFormat</a> *triangle)</td></tr>
<tr class="memdesc:a744f19b2f2880642d0d3688196b81c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uśrednia trzy normalne trójkąta. <br /></td></tr>
<tr class="separator:a744f19b2f2880642d0d3688196b81c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7e1e869699df7844358e73dc5b87a"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#abaa7e1e869699df7844358e73dc5b87a">BarycentricCoords</a> (DirectX::XMFLOAT2 &amp;vertex1, DirectX::XMFLOAT2 &amp;vertex2, DirectX::XMINT2 &amp;point)</td></tr>
<tr class="memdesc:abaa7e1e869699df7844358e73dc5b87a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wylicza głębokość dla poszczególnych wierzchołków trójkąta.  <a href="#abaa7e1e869699df7844358e73dc5b87a">More...</a><br /></td></tr>
<tr class="separator:abaa7e1e869699df7844358e73dc5b87a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac695de01171fea3701c9b460b5189527"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac695de01171fea3701c9b460b5189527"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker_c_p_u.html#ac695de01171fea3701c9b460b5189527">HemisphereViewport</a> (<a class="el" href="struct_triangle4.html">Triangle4</a> &amp;receiver)</td></tr>
<tr class="memdesc:ac695de01171fea3701c9b460b5189527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transformuje wierzchołki w przedziale [-1,1] do współrzednych bufora głębokości. <br /></td></tr>
<tr class="separator:ac695de01171fea3701c9b460b5189527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab939a6b7221064b55e47d1d54d4d59e1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab939a6b7221064b55e47d1d54d4d59e1"></a>
std::tuple&lt; unsigned int, unsigned int, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>FindMaxEmision</b> (std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;emisionLight)</td></tr>
<tr class="separator:ab939a6b7221064b55e47d1d54d4d59e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a049ac6c372d57e55edb955a549b67b86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a049ac6c372d57e55edb955a549b67b86"></a>
float&#160;</td><td class="memItemRight" valign="bottom"><b>m_threshold</b></td></tr>
<tr class="separator:a049ac6c372d57e55edb955a549b67b86"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_lightmap_worker"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_lightmap_worker')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_lightmap_worker.html">LightmapWorker</a></td></tr>
<tr class="memitem:a29b0daabcc73dadbd51060533456b1c8 inherit pro_attribs_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a29b0daabcc73dadbd51060533456b1c8"></a>
<a class="el" href="struct_scene_data.html">SceneData</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>m_data</b></td></tr>
<tr class="separator:a29b0daabcc73dadbd51060533456b1c8 inherit pro_attribs_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acefc075c96f17aba8a350e09ff67afaf inherit pro_attribs_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acefc075c96f17aba8a350e09ff67afaf"></a>
LightmapState&#160;</td><td class="memItemRight" valign="bottom"><b>m_lightmapState</b></td></tr>
<tr class="separator:acefc075c96f17aba8a350e09ff67afaf inherit pro_attribs_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6587d8c3021d9ca23739af5b62985709 inherit pro_attribs_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6587d8c3021d9ca23739af5b62985709"></a>
std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker.html#a6587d8c3021d9ca23739af5b62985709">m_resultData</a></td></tr>
<tr class="memdesc:a6587d8c3021d9ca23739af5b62985709 inherit pro_attribs_class_lightmap_worker"><td class="mdescLeft">&#160;</td><td class="mdescRight">Zawiera współrzędne UV oraz dane kolorów wierzchołków. (Nie przechowuje wierzchołków!!) <br /></td></tr>
<tr class="separator:a6587d8c3021d9ca23739af5b62985709 inherit pro_attribs_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736ad1907e8d142884da9f060980c89c inherit pro_attribs_class_lightmap_worker"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a736ad1907e8d142884da9f060980c89c"></a>
unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_lightmap_worker.html#a736ad1907e8d142884da9f060980c89c">m_depthResolution</a></td></tr>
<tr class="memdesc:a736ad1907e8d142884da9f060980c89c inherit pro_attribs_class_lightmap_worker"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rozdzielczość bufora głębokości. <br /></td></tr>
<tr class="separator:a736ad1907e8d142884da9f060980c89c inherit pro_attribs_class_lightmap_worker"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="abaa7e1e869699df7844358e73dc5b87a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">float LightmapWorkerCPU::BarycentricCoords </td>
          <td>(</td>
          <td class="paramtype">DirectX::XMFLOAT2 &amp;&#160;</td>
          <td class="paramname"><em>vertex1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectX::XMFLOAT2 &amp;&#160;</td>
          <td class="paramname"><em>vertex2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectX::XMINT2 &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wylicza głębokość dla poszczególnych wierzchołków trójkąta. </p>
<p>Wylicza współrzędną barycentryczną punktu względem krawędzie. Współrzędne nie są wyskalowane do jedynki. Należy je wyskalować kiedy się wyliczy wszystkie. </p>

</div>
</div>
<a class="anchor" id="ae0e4f8587be43471b164c4c91f2439e1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LightmapWorkerCPU::BuildResult </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="class_memory_chunk.html">MemoryChunk</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reachedLight</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tworzy tablicę color - uv, która zostanie potem użyta do wyrenderowania lightmapy. </p>
<p>Wszystkie chunki podzielone wcześniej na podczęści są teraz łączone. Każdy obiekt będzie miał swój bufor. </p>

</div>
</div>
<a class="anchor" id="a46b255d2928d397250180d951371f66a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_triangle4.html">Triangle4</a> LightmapWorkerCPU::EmiterCoordinatesSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_triangle4.html">Triangle4</a> &amp;&#160;</td>
          <td class="paramname"><em>emiter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wyliczamy wektory równoległe do płaszczyzny i wzajemnie ortogonalne. </p>
<p>Posłużą one za układ współrzędnych, w którym będzie wyrażony rzut trójkąta. W zasadzie ich orientacja jest dowolna, ważne żeby były stosowane te same wektory do wszystkich rzutów. </p>

</div>
</div>
<a class="anchor" id="af995ff4c404c180ef800a2425eb19bcb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DirectX::XMFLOAT3 LightmapWorkerCPU::HemisphereCast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_triangle4.html">Triangle4</a> &amp;&#160;</td>
          <td class="paramname"><em>emiter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_triangle4.html">Triangle4</a> &amp;&#160;</td>
          <td class="paramname"><em>receiver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectX::XMMATRIX &amp;&#160;</td>
          <td class="paramname"><em>emiterViewMatrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wylicza współrzędne trójkąta zrzutowanego na płaszczyznę koła. Współrzędne są dwuwymiarowe, co pozwala łatwo przejść z nich na indeksy do bufora głębokości. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">receiver</td><td>Trójkąt do zrzutowania. W tej zmiennej zwracany jest trójkąt wynikowy. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Zwraca wektor z głębokościami dla każdego trójkąta. Jeżeli jakiś wierzchołek znajduje się za płaszczyzną rzutowania, funkcja zwraca (-1.0, -1.0, -1.0). W normalnej sytuacji wszystkie współrzędne są dodatnie. </dd></dl>

</div>
</div>
<a class="anchor" id="ac4ed6504329d00e9d0391a2158cd25b0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">XMVECTOR LightmapWorkerCPU::ProjectPointToPlane </td>
          <td>(</td>
          <td class="paramtype">DirectX::XMVECTOR&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_triangle4.html">Triangle4</a> &amp;&#160;</td>
          <td class="paramname"><em>coordsSystem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wylicza rzut punktu na płaszczyznę. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">point</td><td>Punkt wyrażony jako wektor znormalizowany od środka hemisfery do rzutowanego punktu. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coordsSystem</td><td>Opisuje układ współrzędnych w jakim ma być wyrażony zwracany punkt. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Funkcja zwaraca dwuwymiarowy wektor oznaczający punkt we współrzednych w podanym układzie współrzędnych. </dd></dl>

</div>
</div>
<a class="anchor" id="af0ba92104ba2853a8f03d3575f041fc2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LightmapWorkerCPU::RasterizeTriangle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_triangle4.html">Triangle4</a> &amp;&#160;</td>
          <td class="paramname"><em>triangle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectX::XMFLOAT3 *&#160;</td>
          <td class="paramname"><em>depths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>chunkIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>triangleIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;&#160;</td>
          <td class="paramname"><em>depthBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_memory_chunk.html">MemoryChunk</a> &amp;&#160;</td>
          <td class="paramname"><em>indexBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Rasteryzuje podany trójkąt. Sprawdza czy jest bliżej emitera od ostatnio wpisanego trójkąta na podstawie bufora głębokości i jeżeli tak, to zapisuje nowy trójkąt. </p>
<p>Rasteryzacja zrobiona mniej więcej na podstawie strony: <a href="https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/">https://fgiesen.wordpress.com/2013/02/06/the-barycentric-conspirac/</a> Warto przeczytać też kilka tematów pokrewnych. Na razie implementuję wersję niewydajną. Może potem przerobię na lepszą. W każdym razie warto zauważyć, że ten algorytm jest bardzo dobry do zrównoleglania, może da się to jakoś sprytnie wykorzystać.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triangle</td><td>Trójkąt do rasteryzacji. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depths</td><td>Odległości (głębokości) kolejnych wierzchołków trójkąta od emitera. (Tu jest małe oszustwo, zobaczymy jak będzie się sprawdzać, odległości są liczone do środka emitera). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">chunkIdx</td><td>Indeks MemoryChunka do wpisania do bufora indeksów. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">triangleIdx</td><td>Indeks trójkąta, który trafi do bufora indeksów. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">depthBuffer</td><td>Bufor głębokości. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indexBuffer</td><td>Bufor indeksów. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>D:/ProgramyVS/SWEngine/EngineRepo/EngineCode/EngineEditor/LightmapsTool/LightmapWorkers/<a class="el" href="_lightmap_worker_c_p_u_8h_source.html">LightmapWorkerCPU.h</a></li>
<li>D:/ProgramyVS/SWEngine/EngineRepo/EngineCode/EngineEditor/LightmapsTool/LightmapWorkers/LightmapWorkerCPU.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue May 24 2016 14:20:59 for Schopenhauers Weltschmerz Engine by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
